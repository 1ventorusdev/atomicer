<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tableau Périodique</title>
    <!-- Inclusion de Three.js depuis un CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Inclusion de la bibliothèque pour les contrôles -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #b4b4b4;
            /* fond de page */
        }

        /* Légende des couleurs */
        #legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px auto;
            max-width: 1200px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 0px;
            font-size: 1em;
        }

        .legend-item .color-box {
            width: 15px;
            height: 15px;
            display: inline-block;
            margin-right: 1px;
            border: 1px solid #000;
        }

        #periodic-table {
            display: grid;
            grid-template-columns: repeat(18, 1fr);
            gap: 5px;
            justify-content: center;
            padding: 20px;
            max-width: 1200px;
            margin: auto;
        }

        .element {
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 1px solid black;
            background-color: lightgray;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }

        .element:hover {
            background-color: darkgray;
        }

        /* Style pour les cases vides */
        .element.empty {
            background-color: #b4b4b4;
            border: none;
            cursor: default;
        }

        .element.empty:hover {
            background-color: #b4b4b4;
        }

        #lanthanides,
        #actinides {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            gap: 5px;
            justify-content: center;
            padding: 10px;
            max-width: 900px;
            margin: auto;
        }

        #popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 1px solid black;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
        }

        #close-popup {
            cursor: pointer;
            margin-top: 10px;
            color: red;
        }

        /* Styles mobile-friendly */
        @media (max-width: 768px) {
            #periodic-table {
                grid-template-columns: repeat(6, 1fr);
                max-width: 90%;
            }

            .element {
                width: 40px;
                height: 40px;
                font-size: 0.8em;
            }

            #lanthanides,
            #actinides {
                grid-template-columns: repeat(6, 1fr);
                max-width: 90%;
            }

            #legend .legend-item {
                font-size: 0.8em;
                margin: 2px;
            }

            #atom-visualization {
                width: 90vw;
                height: 90vw;
            }
        }
    </style>
</head>

<body>
    <h1>Tableau Périodique</h1>
    <div id="legend"></div>
    <div id="periodic-table"></div>
    <!-- <h2>Lanthanides</h2> -->
    <div id="lanthanides"></div>
    <!-- <h2>Actinides</h2> -->
    <div id="actinides"></div>
    <div id="popup">
        <div id="popup-content"></div>
        <button id="close-popup">Fermer</button>
        
    </div>

    <div id="other_page">
        <ul>
            <li>
                <a href="les_atomes.html">Les Atomes</a>
            </li>
            <li>
                <a href="les_representation.html">Les Représentations</a>
            </li>
            <li>
                <a href="methode_d_identification.html">Méthode d'identification</a>
            </li>
        </ul>
    </div>
    <script>
        function hexToRgb(hex) {
    // Convertit le hex en RGB (retourne une chaîne de type "rgb(r, g, b)")
    let r = parseInt(hex.slice(1, 3), 16);
    let g = parseInt(hex.slice(3, 5), 16);
    let b = parseInt(hex.slice(5, 7), 16);
    return `rgb(${r}, ${g}, ${b})`;
}

        document.addEventListener("DOMContentLoaded", () => {

            /* --- Création de la légende --- */
            const legendContainer = document.getElementById("legend");
            const legendData = {
                "Alkali metals": "#FF4C4C",
                "Alkaline earth metals": "#FFCC66",
                "Transition metals": "#FFD700",
                "Post-transition metals": "#A9A9A9",
                "Metalloids": "#99FF99",
                "Nonmetals": "#66CCFF",
                "Halogens": "#FF66CC",
                "Noble gases": "#CCCCFF",
                "Lanthanides": "#FF9F00",
                "Actinides": "#FF6633",
                "Unknown": "#6e6e6e"
            };
            // Pour chaque item de la légende, on ajoute aussi des écouteurs d'événements
            for (const group in legendData) {
                const item = document.createElement("div");
                item.className = "legend-item";
                item.innerHTML = `<span class="color-box" style="background-color: ${legendData[group]};"></span>&nbsp;${group}&nbsp;&nbsp;&nbsp;`;
                legendContainer.appendChild(item);

                // Récupération de la couleur associée à l'item (convertie en RGB)
                const hoveredColorRgb = hexToRgb(legendData[group]);

                item.addEventListener("mouseenter", () => {
    const elements = document.querySelectorAll('.element');
    elements.forEach(el => {
        
        

        // On ne modifie que les cases non vides ayant une couleur d'origine définie
        if (!el.classList.contains("empty") && el.style.backgroundColor) {

            if (!el.dataset.savedColor) {
                el.dataset.savedColor = el.style.backgroundColor;
            }
            // Conversion de la couleur d'origine en RGB pour comparaison
            if (el.style.backgroundColor === hoveredColorRgb) {
                // On laisse la couleur d'origine
                el.style.backgroundColor = el.dataset.originalColor;
            } else {
                el.style.backgroundColor = "gray";
            }
        }
    });
});


item.addEventListener("mouseleave", () => {
    const elements = document.querySelectorAll('.element');
    elements.forEach(el => {
        if (!el.classList.contains("empty") && el.dataset.savedColor) {
            // Restaurer la couleur sauvegardée à partir du data-* attribut
            el.style.backgroundColor = el.dataset.savedColor;
            // Nettoyer l'attribut une fois restauré
            delete el.dataset.savedColor;
        }
    });
});
            }

            fetch("atoms.json")
                .then(response => response.json())
                .then(data => {
                    const tableContainer = document.getElementById("periodic-table");
                    const lanthanidesContainer = document.getElementById("lanthanides");
                    const actinidesContainer = document.getElementById("actinides");
                    const popup = document.getElementById("popup");
                    const popupContent = document.getElementById("popup-content");
                    const closePopup = document.getElementById("close-popup");

                    const groupColors = {
                        "Alkali metals": "#FF4C4C",            // Plus intense et clair pour les métaux alcalins
                        "Alkaline earth metals": "#FFCC66",     // Une couleur plus chaude et dorée pour les métaux alcalino-terreux
                        "Transition metals": "#FFD700",         // L'or pour représenter les métaux de transition
                        "Post-transition metals": "#A9A9A9",    // Gris métallique pour les métaux post-transition
                        "Metalloids": "#99FF99",                // Une teinte plus douce et verte pour les métalloïdes
                        "Nonmetals": "#66CCFF",                 // Bleu clair pour les non-métaux
                        "Halogens": "#FF66CC",                  // Un rose-violet lumineux pour les halogènes
                        "Noble gases": "#CCCCFF",               // Bleu pâle pour les gaz nobles
                        "Lanthanides": "#FF9F00",               // Une teinte orange plus saturée pour les lanthanides
                        "Actinides": "#FF6633",                  // Rouge-orangé pour les actinides
                        "Unknown": "#6e6e6e"                    // Gris pour les éléments inconnus
                    };



                    // Création d'un objet pour accéder rapidement aux atomes par position "période-groupe"
                    const elementPositions = {};
                    const lanthanides = [];
                    const actinides = [];
                    data.forEach(atom => {
                        if (atom.atomicNumber >= 58 && atom.atomicNumber <= 71) {
                            lanthanides.push(atom);
                        } else if (atom.atomicNumber >= 90 && atom.atomicNumber <= 103) {
                            actinides.push(atom);
                        } else {
                            elementPositions[`${atom.period}-${atom.group}`] = atom;
                        }
                    });

                    // Générer un tableau de 7 périodes x 18 groupes
                    for (let row = 1; row <= 7; row++) {
                        for (let col = 1; col <= 18; col++) {
                            const positionKey = `${row}-${col}`;
                            const element = document.createElement("div");
                            element.className = "element";

                            if (elementPositions[positionKey]) {
                                const atom = elementPositions[positionKey];
                                element.style.backgroundColor = groupColors[atom.category] || "lightgray";
                                element.innerHTML = `<strong>${atom.symbol}</strong><p style="font-size:10px; margin: 2px">${atom.name}</p>${atom.atomicNumber}`;
                                element.addEventListener("click", () => {
                                    // Contenu du popup incluant une div pour la visualisation 3D
                                    popupContent.innerHTML = `
                    <h2>${atom.name} (${atom.symbol})</h2>
                    <p>Numéro Atomique: ${atom.atomicNumber}</p>
                    <p>Masse Atomique: ${atom.atomicMass}</p>
                    <p>Caégorie: ${atom.category}</p>
                    <p>Période: ${atom.period}</p>
                    <p>Configuration Électronique: ${atom.electronConfiguration}</p>
                    <p>Électronégativité: ${atom.electronegativity || "N/A"}</p>
                    <p>Découvert par: ${atom.discoveredBy || "Inconnu"}</p>
                    <p>Année de Découverte: ${atom.discoveryYear || "Inconnue"}</p>
                    <p style="text-decoration: underline"><strong>Representation de bohr</strong></p>
                    <div id="atom-visualization" style="width:400px; height:400px; margin: auto;"></div>
                  `;
                                    popup.style.display = "block";
                                    popup.style.backgroundColor = groupColors[atom.category] || "lightgray";
                                    initAtom3D(atom); // Initialise la visualisation 3D pour cet atome
                                });
                            } else {
                                // Si aucun atome n'est associé à cette case, on lui ajoute la classe "empty"
                                element.classList.add("empty");
                            }
                            tableContainer.appendChild(element);
                        }
                    }

                    lanthanides.forEach(atom => {
                        const element = document.createElement("div");
                        element.className = "element";
                        element.style.backgroundColor = groupColors["Lanthanides"];
                        element.innerHTML = `<strong>${atom.symbol}</strong><p style="font-size:10px; margin: 2px">${atom.name}</p>${atom.atomicNumber}`;
                        element.addEventListener("click", () => {
                            popupContent.innerHTML = `
                    <h2>${atom.name} (${atom.symbol})</h2>
                    <p>Numéro Atomique: ${atom.atomicNumber}</p>
                    <p>Masse Atomique: ${atom.atomicMass}</p>
                    <p>Groupe: ${atom.group}</p>
                    <p>Période: ${atom.period}</p>
                    <p>Configuration Électronique: ${atom.electronConfiguration}</p>
                    <p>Électronégativité: ${atom.electronegativity || "N/A"}</p>
                    <p>Découvert par: ${atom.discoveredBy || "Inconnu"}</p>
                    <p>Année de Découverte: ${atom.discoveryYear || "Inconnue"}</p>
                    <p style="text-decoration: underline"><strong>Representation de bohr</strong></p>
                    <div id="atom-visualization" style="width:400px; height:400px; margin: auto;"></div>
                  `;
                            popup.style.display = "block";
                            popup.style.backgroundColor = groupColors["Lanthanides"] || "lightgray";
                            initAtom3D(atom); // Initialise la visualisation 3D pour cet atome
                        });
                        lanthanidesContainer.appendChild(element);
                    });

                    actinides.forEach(atom => {
                        const element = document.createElement("div");
                        element.className = "element";
                        element.style.backgroundColor = groupColors["Actinides"];
                        element.innerHTML = `<strong>${atom.symbol}</strong><p style="font-size:10px; margin: 2px">${atom.name}</p>${atom.atomicNumber}`;
                        element.addEventListener("click", () => {
                            popupContent.innerHTML = `
                    <h2>${atom.name} (${atom.symbol})</h2>
                    <p>Numéro Atomique: ${atom.atomicNumber}</p>
                    <p>Masse Atomique: ${atom.atomicMass}</p>
                    <p>Groupe: ${atom.group}</p>
                    <p>Période: ${atom.period}</p>
                    <p>Configuration Électronique: ${atom.electronConfiguration}</p>
                    <p>Électronégativité: ${atom.electronegativity || "N/A"}</p>
                    <p>Découvert par: ${atom.discoveredBy || "Inconnu"}</p>
                    <p>Année de Découverte: ${atom.discoveryYear || "Inconnue"}</p>
                    <p style="text-decoration: underline"><strong>Representation de bohr</strong></p>
                    <div id="atom-visualization" style="width:400px; height:400px; margin: auto;"></div>
                  `;
                            popup.style.display = "block";
                            popup.style.backgroundColor = groupColors["Actinides"] || "lightgray";
                            initAtom3D(atom); // Initialise la visualisation 3D pour cet atome
                        });
                        actinidesContainer.appendChild(element);
                    });

                    closePopup.addEventListener("click", () => {
                        popup.style.display = "none";
                    });
                })
                .catch(error => console.error("Erreur lors du chargement des données", error));

            // Fonction pour initialiser la visualisation 3D de l'atome avec Three.js
            function initAtom3D(atom) {
                const vizContainer = document.getElementById("atom-visualization");
                const width = vizContainer.clientWidth;
                const height = vizContainer.clientHeight;

                // Création de la scène, de la caméra et du renderer
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.z = 6;
                camera.position.y = 1;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                // Vider le conteneur et ajouter le canvas de Three.js
                vizContainer.innerHTML = "";
                vizContainer.appendChild(renderer.domElement);

                // Ajout de lumières
                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // Création du noyau composé de protons et de neutrons
                const nucleusGroup = new THREE.Group();

                // Calculer le nombre de neutrons et de protons
                const protonsCount = atom.atomicNumber;
                const neutronsCount = Math.round(atom.atomicMass) - protonsCount;

                // Fonction pour ajouter des particules (protons ou neutrons)
                function createNucleon(isProton) {
                    const nucleonGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                    const nucleonMaterial = new THREE.MeshPhongMaterial({
                        color: isProton ? 0xff0000 : 0x949494, // Rouge pour proton, bleu pour neutron
                    });
                    const nucleon = new THREE.Mesh(nucleonGeometry, nucleonMaterial);

                    // Positionnement aléatoire autour du centre du noyau
                    const distance = Math.random() * 0.5; // Distance depuis le centre du noyau
                    const angle = Math.random() * Math.PI * 2; // Angle autour de l'axe Y
                    nucleon.position.set(
                        distance * Math.cos(angle),
                        distance * Math.sin(angle),
                        (Math.random() - 0.5) * 0.5 // Aléatoire sur l'axe Z pour donner un effet 3D
                    );

                    return nucleon;
                }

                // Ajouter les protons
                for (let i = 0; i < protonsCount; i++) {
                    nucleusGroup.add(createNucleon(true)); // Protons
                }

                // Ajouter les neutrons
                for (let i = 0; i < neutronsCount; i++) {
                    nucleusGroup.add(createNucleon(false)); // Neutrons
                }

                scene.add(nucleusGroup);

                // Groupe pour les électrons
                const electronGroup = new THREE.Group();
                const shells = atom.electronShells; // Ex: [1] pour l'hydrogène, [2, 8, 1] pour le sodium, etc.
                if (shells && shells.length) {
                    shells.forEach((electronCount, shellIndex) => {
                        const orbitRadius = 1 + shellIndex; // Rayon de l'orbite (modifiable selon vos préférences)
                        // Groupe pour la couche électronique
                        const shellGroup = new THREE.Group();
                        for (let i = 0; i < electronCount; i++) {
                            const angle = (i / electronCount) * Math.PI * 2;
                            const electronGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                            const electronMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
                            const electron = new THREE.Mesh(electronGeometry, electronMaterial);
                            // Positionnement sur un cercle dans le plan XZ
                            electron.position.set(
                                orbitRadius * Math.cos(angle),
                                0,
                                orbitRadius * Math.sin(angle)
                            );
                            shellGroup.add(electron);
                        }
                        electronGroup.add(shellGroup);
                    });
                }
                scene.add(electronGroup);

                // Boucle d'animation pour faire tourner les électrons
                function animate() {
                    requestAnimationFrame(animate);
                    electronGroup.rotation.y += 0.01;
                    nucleusGroup.rotation.y += 0.002;  // Rotation lente du noyau
                    renderer.render(scene, camera);
                }
                animate();

                // Variables pour la gestion du clic et du mouvement de la souris
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                // Fonction de gestion de la souris
                function onMouseMove(event) {
                    if (!isDragging) return;

                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;

                    // Mettre à jour l'angle de la caméra en fonction des mouvements de la souris
                    camera.rotation.y -= deltaX * 0.005; // Mouvement horizontal
                    camera.rotation.x -= deltaY * 0.005; // Mouvement vertical (peut être limité pour éviter des inversions de caméra)

                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }

                function onMouseDown(event) {
                    if (event.button === 0) { // Clic gauche de la souris
                        isDragging = true;
                        previousMousePosition = { x: event.clientX, y: event.clientY };
                    }
                }

                function onMouseUp() {
                    isDragging = false;
                }

                // Ajouter les écouteurs d'événements pour le mouvement de la souris
                vizContainer.addEventListener('mousemove', onMouseMove);
                vizContainer.addEventListener('mousedown', onMouseDown);
                vizContainer.addEventListener('mouseup', onMouseUp);

                // Ajout de la fonctionnalité de zoom via la molette
                let zoomSpeed = 0.1; // Vitesse du zoom
                let minZoom = 3; // Zoom minimum
                let maxZoom = 15; // Zoom maximum

                // Écouter l'événement de la molette pour zoomer
                vizContainer.addEventListener('wheel', (event) => {
                    if (event.deltaY < 0) {
                        camera.position.z -= zoomSpeed; // Zoom avant (molette vers le bas)
                    } else {
                        camera.position.z += zoomSpeed; // Zoom arrière (molette vers le haut)
                    }

                    // Limiter le zoom
                    if (camera.position.z < minZoom) {
                        camera.position.z = minZoom;
                    } else if (camera.position.z > maxZoom) {
                        camera.position.z = maxZoom;
                    }

                    event.preventDefault(); // Empêcher le comportement par défaut (défilement de la page)
                });
            }
        });
    </script>
</body>

</html>