<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tableau Périodique</title>
    <link rel="stylesheet" href="style.css">
    <!-- Inclusion de Three.js depuis un CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Inclusion de la bibliothèque pour les contrôles -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <script defer src="script.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: white;
            /* fond de page */
        }

        #periodic-table {
            display: grid;
            grid-template-columns: repeat(18, 1fr);
            gap: 5px;
            justify-content: center;
            padding: 20px;
            max-width: 1200px;
            margin: auto;
        }

        .element {
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 1px solid black;
            background-color: lightgray;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }

        .element:hover {
            background-color: darkgray;
        }

        /* Style pour les cases vides */
        .element.empty {
            background-color: white;
            border: none;
            cursor: default;
        }

        .element.empty:hover {
            background-color: white;
        }

        #popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 1px solid black;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
        }

        #close-popup {
            cursor: pointer;
            margin-top: 10px;
            color: red;
        }
    </style>
</head>

<body>
    <h1>Tableau Périodique</h1>
    <div id="periodic-table"></div>
    <div id="popup">
        <div id="popup-content"></div>
        <button id="close-popup">Fermer</button>
    </div>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            fetch("atoms.json")
                .then(response => response.json())
                .then(data => {
                    const tableContainer = document.getElementById("periodic-table");
                    const popup = document.getElementById("popup");
                    const popupContent = document.getElementById("popup-content");
                    const closePopup = document.getElementById("close-popup");

                    // Création d'un objet pour accéder rapidement aux atomes par position "période-groupe"
                    const elementPositions = {};
                    data.forEach(atom => {
                        elementPositions[`${atom.period}-${atom.group}`] = atom;
                    });

                    // Générer un tableau de 7 périodes x 18 groupes
                    for (let row = 1; row <= 7; row++) {
                        for (let col = 1; col <= 18; col++) {
                            const positionKey = `${row}-${col}`;
                            const element = document.createElement("div");
                            element.className = "element";

                            if (elementPositions[positionKey]) {
                                const atom = elementPositions[positionKey];
                                element.innerHTML = `<strong>${atom.symbol}</strong><p style="font-size:10px">${atom.name}</p>${atom.atomicNumber}`;
                                element.addEventListener("click", () => {
                                    // Contenu du popup incluant une div pour la visualisation 3D
                                    popupContent.innerHTML = `
                    <h2>${atom.name} (${atom.symbol})</h2>
                    <p>Numéro Atomique: ${atom.atomicNumber}</p>
                    <p>Masse Atomique: ${atom.atomicMass}</p>
                    <p>Groupe: ${atom.group}</p>
                    <p>Période: ${atom.period}</p>
                    <p>Électronégativité: ${atom.electronegativity || "N/A"}</p>
                    <p>Découvert par: ${atom.discoveredBy || "Inconnu"}</p>
                    <p>Année de Découverte: ${atom.discoveryYear || "Inconnue"}</p>
                    <div id="atom-visualization" style="width:400px; height:400px; margin: auto;"></div>
                  `;
                                    popup.style.display = "block";
                                    initAtom3D(atom); // Initialise la visualisation 3D pour cet atome
                                });
                            } else {
                                // Si aucun atome n'est associé à cette case, on lui ajoute la classe "empty"
                                element.classList.add("empty");
                            }
                            tableContainer.appendChild(element);
                        }
                    }

                    closePopup.addEventListener("click", () => {
                        popup.style.display = "none";
                    });
                })
                .catch(error => console.error("Erreur lors du chargement des données", error));

            // Fonction pour initialiser la visualisation 3D de l'atome avec Three.js
            function initAtom3D(atom) {
                const vizContainer = document.getElementById("atom-visualization");
                const width = vizContainer.clientWidth;
                const height = vizContainer.clientHeight;

                // Création de la scène, de la caméra et du renderer
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.z = 6;
                camera.position.y = 1;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                // Vider le conteneur et ajouter le canvas de Three.js
                vizContainer.innerHTML = "";
                vizContainer.appendChild(renderer.domElement);

                // Ajout de lumières
                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // Création du noyau composé de protons et de neutrons
                const nucleusGroup = new THREE.Group();

                // Calculer le nombre de neutrons et de protons
                const protonsCount = atom.atomicNumber;
                const neutronsCount = Math.round(atom.atomicMass) - protonsCount;

                // Fonction pour ajouter des particules (protons ou neutrons)
                function createNucleon(isProton) {
                    const nucleonGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                    const nucleonMaterial = new THREE.MeshPhongMaterial({
                        color: isProton ? 0xff0000 : 0x0000ff, // Rouge pour proton, bleu pour neutron
                    });
                    const nucleon = new THREE.Mesh(nucleonGeometry, nucleonMaterial);

                    // Positionnement aléatoire autour du centre du noyau
                    const distance = Math.random() * 0.5; // Distance depuis le centre du noyau
                    const angle = Math.random() * Math.PI * 2; // Angle autour de l'axe Y
                    nucleon.position.set(
                        distance * Math.cos(angle),
                        distance * Math.sin(angle),
                        (Math.random() - 0.5) * 0.5 // Aléatoire sur l'axe Z pour donner un effet 3D
                    );

                    return nucleon;
                }

                // Ajouter les protons
                for (let i = 0; i < protonsCount; i++) {
                    nucleusGroup.add(createNucleon(true)); // Protons
                }

                // Ajouter les neutrons
                for (let i = 0; i < neutronsCount; i++) {
                    nucleusGroup.add(createNucleon(false)); // Neutrons
                }

                scene.add(nucleusGroup);

                // Groupe pour les électrons
                const electronGroup = new THREE.Group();
                const shells = atom.electronShells; // Ex: [1] pour l'hydrogène, [2, 8, 1] pour le sodium, etc.
                if (shells && shells.length) {
                    shells.forEach((electronCount, shellIndex) => {
                        const orbitRadius = 1 + shellIndex; // Rayon de l'orbite (modifiable selon vos préférences)
                        // Groupe pour la couche électronique
                        const shellGroup = new THREE.Group();
                        for (let i = 0; i < electronCount; i++) {
                            const angle = (i / electronCount) * Math.PI * 2;
                            const electronGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                            const electronMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
                            const electron = new THREE.Mesh(electronGeometry, electronMaterial);
                            // Positionnement sur un cercle dans le plan XZ
                            electron.position.set(
                                orbitRadius * Math.cos(angle),
                                0,
                                orbitRadius * Math.sin(angle)
                            );
                            shellGroup.add(electron);
                        }
                        electronGroup.add(shellGroup);
                    });
                }
                scene.add(electronGroup);

                // Boucle d'animation pour faire tourner les électrons
                function animate() {
                    requestAnimationFrame(animate);
                    electronGroup.rotation.y += 0.01;
                    nucleusGroup.rotation.y += 0.002;  // Rotation lente du noyau
                    renderer.render(scene, camera);
                }
                animate();

                // Variables pour la gestion du clic et du mouvement de la souris
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                // Fonction de gestion de la souris
                function onMouseMove(event) {
                    if (!isDragging) return;

                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;

                    // Mettre à jour l'angle de la caméra en fonction des mouvements de la souris
                    camera.rotation.y -= deltaX * 0.005; // Mouvement horizontal
                    camera.rotation.x -= deltaY * 0.005; // Mouvement vertical (peut être limité pour éviter des inversions de caméra)

                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }

                function onMouseDown(event) {
                    if (event.button === 0) { // Clic gauche de la souris
                        isDragging = true;
                        previousMousePosition = { x: event.clientX, y: event.clientY };
                    }
                }

                function onMouseUp() {
                    isDragging = false;
                }

                // Ajouter les écouteurs d'événements pour le mouvement de la souris
                vizContainer.addEventListener('mousemove', onMouseMove);
                vizContainer.addEventListener('mousedown', onMouseDown);
                vizContainer.addEventListener('mouseup', onMouseUp);

                // Ajout de la fonctionnalité de zoom via la molette
                let zoomSpeed = 0.1; // Vitesse du zoom
                let minZoom = 3; // Zoom minimum
                let maxZoom = 15; // Zoom maximum

                // Écouter l'événement de la molette pour zoomer
                vizContainer.addEventListener('wheel', (event) => {
                    if (event.deltaY < 0) {
                        camera.position.z -= zoomSpeed; // Zoom avant (molette vers le bas)
                    } else {
                        camera.position.z += zoomSpeed; // Zoom arrière (molette vers le haut)
                    }

                    // Limiter le zoom
                    if (camera.position.z < minZoom) {
                        camera.position.z = minZoom;
                    } else if (camera.position.z > maxZoom) {
                        camera.position.z = maxZoom;
                    }

                    event.preventDefault(); // Empêcher le comportement par défaut (défilement de la page)
                });
            }
        });
    </script>
</body>

</html>